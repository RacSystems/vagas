unit uCadastroView;

interface

uses
  Winapi.Windows, Winapi.Messages, System.SysUtils, System.Variants, System.Classes, Vcl.Graphics,
  Vcl.Controls, Vcl.Forms, Vcl.Dialogs, FireDAC.Stan.Intf, FireDAC.Stan.Option,
  FireDAC.Stan.Error, FireDAC.UI.Intf, FireDAC.Phys.Intf, FireDAC.Stan.Def,
  FireDAC.Stan.Pool, FireDAC.Stan.Async, FireDAC.Phys, FireDAC.Phys.ODBC,
  FireDAC.Phys.ODBCDef, FireDAC.VCLUI.Wait, FireDAC.Stan.Param, FireDAC.DatS,
  FireDAC.DApt.Intf, FireDAC.DApt, Data.DB, FireDAC.Comp.DataSet,
  FireDAC.Comp.Client, FireDAC.Phys.ODBCBase, Vcl.ComCtrls, Vcl.StdCtrls,
  Vcl.Buttons, System.ImageList, Vcl.ImgList, Vcl.Imaging.pngimage,
  Vcl.ExtCtrls, FireDAC.Comp.BatchMove.DataSet, FireDAC.Comp.BatchMove,
  Vcl.Grids, Vcl.DBGrids, Vcl.Mask, Vcl.DBCtrls, FireDAC.Comp.BatchMove.Text;

type
  TForm1 = class(TForm)
    FDConn: TFDConnection;
    ODBC_CSV: TFDPhysODBCDriverLink;
    DSPrinc: TDataSource;
    BatchMove: TFDBatchMove;
    Panel1: TPanel;
    Panel2: TPanel;
    Image1: TImage;
    Label1: TLabel;
    ImageList1: TImageList;
    PageControl1: TPageControl;
    TabSheet1: TTabSheet;
    TabCadastro: TTabSheet;
    Panel4: TPanel;
    DBGrid1: TDBGrid;
    qryPrinc: TFDQuery;
    btnEditar: TSpeedButton;
    btnCancelar: TSpeedButton;
    btnExcluir: TSpeedButton;
    btnInserir: TSpeedButton;
    btnSalvar: TSpeedButton;
    Label3: TLabel;
    lblEmail: TLabel;
    Label5: TLabel;
    dbEdtNome: TDBEdit;
    dbEdtEmail: TDBEdit;
    dbEdtDocumento: TDBEdit;
    Panel3: TPanel;
    Label2: TLabel;
    edtPesquisar: TEdit;
    TimerLiberarPage: TTimer;
    WriterCSV: TFDBatchMoveTextWriter;
    Reader: TFDBatchMoveDataSetReader;
    qryPrincID: TIntegerField;
    qryPrincNome: TStringField;
    qryPrincEmail: TStringField;
    qryPrincDocumento: TFloatField;
    memPrinc: TFDMemTable;
    BitBtn1: TBitBtn;
    SaveDialog1: TSaveDialog;
    procedure btnPesquisarClick(Sender: TObject);
    procedure FormCreate(Sender: TObject);
    procedure btnInserirClick(Sender: TObject);
    procedure btnEditarClick(Sender: TObject);
    procedure btnCancelarClick(Sender: TObject);
    procedure btnSalvarClick(Sender: TObject);
    procedure btnExcluirClick(Sender: TObject);
    procedure qryPrincBeforePost(DataSet: TDataSet);
    procedure PageControl1Change(Sender: TObject);
    procedure DSPrincStateChange(Sender: TObject);
    procedure TimerLiberarPageTimer(Sender: TObject);
    procedure qryPrincAfterScroll(DataSet: TDataSet);
    procedure qryPrincAfterPost(DataSet: TDataSet);
    procedure qryPrincBeforeDelete(DataSet: TDataSet);
    procedure qryPrincAfterDelete(DataSet: TDataSet);
    procedure edtPesquisarChange(Sender: TObject);
    procedure BitBtn1Click(Sender: TObject);
    procedure qryPrincBeforeEdit(DataSet: TDataSet);
    procedure dbEdtNomeKeyPress(Sender: TObject; var Key: Char);
  private
    { Private declarations }
    procedure controleBotoes;
    procedure atualizarCsv;
    function ValidarCPF(const CPF: String): Boolean;
    function ValidarCnpj(const CNPJ: string): Boolean;
  public
    { Public declarations }
  end;

var
  Form1: TForm1;

implementation

{$R *.dfm}

procedure TForm1.atualizarCsv;
begin
  // Extrai a regra duplicada para esta procedure, centralizando a atualização do CSV.
  try
    // Copia dados para TFDMemTable para evitar lock do arquivo CSV durante o BatchMove.
    memPrinc.CopyDataSet(qryPrinc, [coStructure, coRestart, coAppend]);

    FDConn.Connected := False;

    BatchMove.Execute;
  finally
    FDConn.Connected := True;
    btnPesquisarClick(nil);
  end;
end;

procedure TForm1.BitBtn1Click(Sender: TObject);
var
  CSVFile: TextFile;
begin
  SaveDialog1.FileName := 'banco.csv';
  // Exporta o conteúdo de qryPrinc linha a linha para CSV (com cabeçalho).
  if SaveDialog1.Execute then
  begin
    AssignFile(CSVFile, SaveDialog1.FileName);
    Rewrite(CSVFile);
    try
      // Cabeçalho do CSV
      Writeln(CSVFile, 'ID,Nome,E-mail,Documento');

      // Percorrer os Registros com o While
      qryPrinc.DisableControls;
      qryPrinc.First;
      while not qryPrinc.Eof do
      begin
        Writeln(CSVFile,
          qryPrinc.FieldByName('ID').AsString + ',' +
          '"' + qryPrinc.FieldByName('Nome').AsString + '",' +
          '"' + qryPrinc.FieldByName('E-mail').AsString + '",' +
          qryPrinc.FieldByName('Documento').AsString
        );
        qryPrinc.Next;
      end;
    finally
      qryPrinc.EnableControls;
      CloseFile(CSVFile);
    end;

    ShowMessage('Exportado com sucesso!');
  end;
end;

procedure TForm1.btnCancelarClick(Sender: TObject);
begin
  qryPrinc.Cancel;
end;

procedure TForm1.btnEditarClick(Sender: TObject);
begin
  qryPrinc.Edit;
end;

procedure TForm1.btnExcluirClick(Sender: TObject);
begin
  qryPrinc.Delete;
end;

procedure TForm1.btnInserirClick(Sender: TObject);
begin
  // Inserção
  memPrinc.CopyDataSet(qryPrinc, [coStructure, coRestart, coAppend]);

  if not qryPrinc.Active then
    btnPesquisarClick(nil);

  if not (qryPrinc.State in [dsEdit, dsInsert]) then
  begin
    PageControl1.ActivePageIndex := 1;  // Gosto de mudar a aba, sempre quando faz uma inserçaõ, pois estamos trabalhando em 2 tabelas.
    qryPrinc.Insert;
  end;
end;

procedure TForm1.btnPesquisarClick(Sender: TObject);
begin
  // Aqui iremos carregar o Filtro da tela.
  qryPrinc.Close;
  qryPrinc.SQL.Text := 'SELECT * FROM [banco.csv]';

  if Trim(edtPesquisar.Text) <> '' then
  begin
    qryPrinc.SQL.Add('WHERE (ID = :id) OR (Nome LIKE :nome)');
    qryPrinc.ParamByName('id').AsInteger  := StrToIntDef(edtPesquisar.Text, -1);
    qryPrinc.ParamByName('nome').AsString := '%' + edtPesquisar.Text + '%';
  end;

  qryPrinc.Open;
end;

procedure TForm1.btnSalvarClick(Sender: TObject);
begin
  qryPrinc.Post;
end;

procedure TForm1.controleBotoes;
begin
  // Utilização de status do Data Source para controlar os botões.
  if qryPrinc.State in [dsEdit, dsInsert] then
  begin
    btnEditar.Enabled  := False;
    btnInserir.Enabled := False;
    btnExcluir.Enabled := False;

    btnCancelar.Enabled := True;
    btnSalvar.Enabled   := True;
  end
  else
  begin
    btnEditar.Enabled  := True;
    btnInserir.Enabled := True;
    btnExcluir.Enabled := True;

    btnCancelar.Enabled := False;
    btnSalvar.Enabled   := False;
  end;
end;

procedure TForm1.dbEdtNomeKeyPress(Sender: TObject; var Key: Char);
begin
  // Regra simples para validar nome apenas com caracteres.
  if not (Key in ['A'..'Z', 'a'..'z', ' ', #8, 'Á'..'Ú', 'á'..'ú']) then
    Key := #0;
end;

procedure TForm1.DSPrincStateChange(Sender: TObject);
begin
  // Atualização de Botoões na mudança de Status do Data.
  controleBotoes;

  TimerLiberarPage.Enabled := False;
  TimerLiberarPage.Enabled := True;
end;

procedure TForm1.edtPesquisarChange(Sender: TObject);
begin
  btnPesquisarClick(nil);
end;

procedure TForm1.FormCreate(Sender: TObject);
begin
  // Inicia na aba principal por padrão.
  PageControl1.ActivePageIndex := 0;

  // Dar open na Qry.
  btnPesquisarClick(nil);

  // Controle de Status de Botões.
  controleBotoes;
end;

procedure TForm1.PageControl1Change(Sender: TObject);
begin
  // Garantia
  if (PageControl1.ActivePageIndex = 0) and (qryPrinc.State in [dsEdit, dsInsert]) then
    qryPrinc.Cancel;
//  controleBotoes;
end;

procedure TForm1.qryPrincAfterDelete(DataSet: TDataSet);
begin
  atualizarCsv;
end;

procedure TForm1.qryPrincAfterPost(DataSet: TDataSet);
begin
  if qryPrinc.State in [dsEdit, dsInsert] then
    qryPrinc.Post;
  qryPrinc.CheckBrowseMode;

  atualizarCsv;

  PageControl1.ActivePageIndex := 0;
end;

procedure TForm1.qryPrincAfterScroll(DataSet: TDataSet);
begin
  TimerLiberarPage.Enabled := False;
  TimerLiberarPage.Enabled := True;
end;

procedure TForm1.qryPrincBeforeDelete(DataSet: TDataSet);
begin
  // Sempre em exclusão ou salvar registro, eu coloco uma confirmação do cliente
  if MessageDlg('Deseja realmente excluir este cliente?', mtConfirmation,
                [mbYes, mbNo], 0) = mrNo then
    abort;
end;

procedure TForm1.qryPrincBeforeEdit(DataSet: TDataSet);
begin
  // Ao editar iremos para a página de cadastro!
  PageControl1.ActivePageIndex := 1;
end;

procedure TForm1.qryPrincBeforePost(DataSet: TDataSet);
var
  MeuId :Integer;
begin
  // Valida campos obrigatórios e formato do documento (CPF/CNPJ).
  if Trim(qryPrincNome.AsString) = '' then
  begin
    showmessage('Necessário preencher o campo nome!');
    abort; // Sempre utilizo em um abort em Post e Delete;
  end
  else if Trim(qryPrincEmail.AsString) = '' then
  begin
    ShowMessage('Necessário preencher o campo Email!');
    abort;
  end;

  // Validação de CNPJ E CPF
  if (
            (Length(dbEdtDocumento.Text) <> 14)
            and
            (Length(dbEdtDocumento.Text) <> 11)
          )  then
  begin
    ShowMessage('Necessário preencher o campo de documento corretamente com 11 ou 14 números, sem caracteres especiais!');
    abort;
  end
  else
  begin
    if Length(dbEdtDocumento.Text) = 11 then
    begin
      // Aqui iremos validar o CPF
      if ValidarCPF(dbEdtDocumento.Text) = True then
      begin
        ShowMessage('CPF está invalido!');
        abort;
      end;
    end
    else
    begin
      // Validação de CNPJ
      if ValidarCnpj(dbEdtDocumento.Text) = False then
      begin
        ShowMessage('CNPJ está invalido!');
        abort;
      end;
    end;
  end;

  // Simples validação confirmando se o usuário realmente quer salvar o cadastro deste cliente.
  if MessageDlg('Deseja realmente deseja salvar o cadastro deste cliente?', mtConfirmation,
              [mbYes, mbNo], 0) = mrNo then
    abort;

  // Incrementação de um novo ID percorrendo todos e vendo qual é o maior numero.
  // Aqui irei utilizar o MemTable, para copiar os arquivos e não percorer o meu qryTable que está sendo utilizado(Isso pode causar problemas).
  // Irei utilizazr a metodologia de loop, ja que não temos um auto inc embutido no nosso banco de dados.
  // Mas também tem a opção de dar UM SELECT MAX FROM TABLE e pegar o id maximo e adiconar + 1.
  MeuId := 0;

  memPrinc.First;
  while not memPrinc.Eof do
  begin
    if memPrinc.FieldByName('ID').AsInteger > MeuId then
      MeuId := memPrinc.FieldByName('ID').AsInteger;

    memPrinc.Next;
  end;

  MeuId := MeuId + 1;
  qryPrincID.AsInteger := MeuId;
end;

procedure TForm1.TimerLiberarPageTimer(Sender: TObject);
begin
  // Vou utilizar a criação desse timer, para ser feito o controle de ativar a  página apenas em edição e inserção.
  TimerLiberarPage.Enabled := False;

  if qryPrinc.State in [dsEdit, dsInsert] then
    TabCadastro.Enabled := True
  else
    TabCadastro.Enabled := False;
end;

function TForm1.ValidarCnpj(const CNPJ: string): Boolean;
var
   n1,n2,n3,n4,n5,n6,n7,n8,n9,n10,n11,n12: integer;
   d1,d2: integer;
   digitado, calculado: string;
begin
   n1:=StrToInt(CNPJ[1]);
   n2:=StrToInt(CNPJ[2]);
   n3:=StrToInt(CNPJ[3]);
   n4:=StrToInt(CNPJ[4]);
   n5:=StrToInt(CNPJ[5]);
   n6:=StrToInt(CNPJ[6]);
   n7:=StrToInt(CNPJ[7]);
   n8:=StrToInt(CNPJ[8]);
   n9:=StrToInt(CNPJ[9]);
   n10:=StrToInt(CNPJ[10]);
   n11:=StrToInt(CNPJ[11]);
   n12:=StrToInt(CNPJ[12]);

   d1:=n12*2+n11*3+n10*4+n9*5+n8*6+n7*7+n6*8+n5*9+n4*2+n3*3+n2*4+n1*5;

   d1:=11-(d1 mod 11);

   if d1>=10 then d1:=0;
     d2:=d1*2+n12*3+n11*4+n10*5+n9*6+n8*7+n7*8+n6*9+n5*2+n4*3+n3*4+n2*5+n1*6;
   d2:=11-(d2 mod 11);

   if d2>=10 then d2:=0;
     calculado:=inttostr(d1)+inttostr(d2);
   digitado:=CNPJ[13]+CNPJ[14];

   if calculado=digitado then
     Result := true

   else
     Result := false;
end;

function TForm1.ValidarCPF(const CPF: String): Boolean;
var
  CPFCalculado : String;
  Soma, Resto, DigitoVerificador, DigitoVerificado2: Integer;
  i: Integer;
begin
  CPFCalculado := '';

  for I := 1 to Length(CPF) do
  begin
    if CharInSet(CPF[I], ['0'..'9']) then
    begin
      CPFCalculado := CPFCalculado + CPF[i];
    end;
  end;

  Soma := 0;
  for i := 1 to 9 do
    Soma := Soma + StrToInt(CPFCalculado[i]) * (11 - i);
  Resto := (Soma * 10) mod 11;
  if (Resto = 10) or (Resto = StrToInt(CPFCalculado[11])) then
  begin
    Result := True;
    Exit;
  end;

  Result := False;
end;

end.
